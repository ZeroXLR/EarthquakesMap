<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Recent Earthquake Markers</title>
	<style>
		html,
		body {
			height: 100%;
			margin: 0;
			padding: 0;
		}

		#map {
			height: 100%;
		}
	</style>
	<link rel="icon" type="image/ico" href="images/quakecon.ico"/>
</head>

<body>
	<div id="map"></div>
	<script type="text/javascript">
		'use strict';
		var globalfunctions = (function main(global) {
			var doc = global.document;
			var storage = global.sessionStorage;
			var console = global.console;
			var key = storage.getItem('GoogleMapsBrowserKey');
			var gloc = global.navigator.geolocation;
			var quakesurl = 'http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson';
			// var markers = [];
			var locationset = storage.getItem('UseOwnLocationDecision') || false;

			// call this block of code asynchronously to make sure that it executes AFTER main() function returns
			global.setTimeout(function() {
				if (key) {
					makescript();
				} else if ((key = global.prompt("Type in your Google Maps API key please!"))) {
					makescript();
					storage.setItem('GoogleMapsBrowserKey', key);
				} else {
					alert("No browser key provided. DIE.");
					throw new Error("Use of Google Maps API without key is deprecated");
				}
			}, 0);

			function makescript() {
				var script = doc.createElement("script");
				script.type = 'text/javascript';
				script.src = "https://maps.googleapis.com/maps/api/js?key=" + key + "&callback=initMap";
				// "https://maps.googleapis.com/maps/api/js?callback=initMap";
				doc.body.appendChild(script);
			}

			// function deletemarkers() {
			// 	var i, len = markers.length;
			// 	for (i = 0; i < len; ++i) {
			// 		markers[i].setMap(null);
			// 	}
			// 	markers = [];
			// }

			function initMap() {
				var maps = google.maps;
				// we unfortunately need a new map everytime; you cannot rebind an existing map to the new div element that would be created upon reload
				var mapdata = newmapdata();
				var location = mapdata.location;
				var map = mapdata.map;
				var mainmarker = mapdata.mainmarker;

				// map initialization factory
				function newmapdata() {
					var location = JSON.parse(locationset) || {
						lat: 51.4778,
						lng: -0.0014
					};
					var map = new maps.Map(doc.getElementById("map"), {
						zoom: 3,
						center: location
					});
					var mainmarker = new maps.Marker({
						position: location,
						map: map,
						icon: 'images/catcon.ico',
						title: 'Royal Observatory at Greenwich',
						animation: maps.Animation.DROP
					});

					return {
						location: location,
						map: map,
						mainmarker: mainmarker
					};
				}

				(function setownlocation() {
					if (locationset) {
						console.log("Location is already set.");
					} else {
						if (gloc && global.confirm('Do you want to set your location?')) {
							gloc.getCurrentPosition(
								function(position) {
									var coords = position.coords;
									location.lat = coords.latitude;
									location.lng = coords.longitude;
									map.setCenter(location);
									mainmarker.setPosition(location);
									mainmarker.setAnimation(maps.Animation.DROP);
									mainmarker.setTitle('You!');
									storage.setItem('UseOwnLocationDecision', JSON.stringify(location));
								},
								function(error) {
									console.error('ERROR(' + error.code + '): ' + error.message);
									alert(error.message + '\n\nDefaulting to the Royal Observatory at Greenwich.');
									storage.setItem('UseOwnLocationDecision', JSON.stringify(location));
								},
								{
									enableHighAccuracy: true,
									timeout: 120000,
									maximumAge: 0
								}
							);
						} else {
							console.warn("Your browser doesn't support geolocation. No worries; defaulting to the Royal Observatory at Greenwich.");
							storage.setItem('UseOwnLocationDecision', JSON.stringify(location));
						}
					}
				})();

				(function fetchquakesdata() {
					var xhr = new XMLHttpRequest();
					xhr.onreadystatechange = function() {
						if (xhr.readyState === 4 && xhr.status === 200) {
							// if (markers.length) {
							// 	deletemarkers();
							// }
							var recentquakes = JSON.parse(xhr.responseText);
							recentquakes.features.forEach(function(element) {
								var marker = new maps.Marker({
									position: {
										lat:element.geometry.coordinates[1],
										lng:element.geometry.coordinates[0]
									},
									map: map,
									icon: 'images/quakecon.ico',
									title: element.properties.title
								});
								// markers.push(marker);
							});
						}
						console.log('Earthquake Data Request is at state ' + xhr.readyState + ' and the current HTTP status is ' + xhr.status);
					};
					xhr.open('GET', quakesurl, true);
					xhr.send();
				})();
			}

			function gm_authFailure() {
					storage.removeItem('key');
					global.alert('DEATH BY AUTHENTICATION FAILURE\n\nLook at the browser console for details');
			};

			return {
				initMap: initMap,
				gm_authFailure: gm_authFailure
			};
		})(this);

		var initMap = globalfunctions.initMap;
		var gm_authFailure = globalfunctions.gm_authFailure;
	</script>
</body>

</html>
